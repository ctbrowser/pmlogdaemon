/* @@@LICENSE
*
*      Copyright (c) 2007-2012 Hewlett-Packard Development Company, L.P.
*      Copyright (c) 2013 LG Electronics
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* LICENSE@@@ */

/**
 ***********************************************************************
 * @file main.c
 *
 * @brief This file contains the Open webOS logging daemon implementation.
 * The syslogd implementation is per RFC 3164.
 * Reference http://www.faqs.org/rfcs/rfc3164.html.
 * Reference http://tools.ietf.org/wg/syslog/draft-ietf-syslog-protocol/
 * e.g. http://tools.ietf.org/html/draft-ietf-syslog-protocol-23.
 *
 * This implementation is a subset of functionality, intended to
 * efficiently address the needs for the Open webOS embedded device.
 *  - it does not support remote logging (not needed)
 *  - it only supports the standard datagram socket on port 514
 *  - it does not support /etc/syslog.conf or standard filtering/redirection
 *
 * Features that may be added:
 *  - support for RFC 3339-style timestamps
 *  - support for advanced file buffering + rotation configuration
 *  - support for custom filtering/redirection
 *
 ***********************************************************************
 */

#include "main.h"

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <pthread.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/syslog.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/un.h>
#include <unistd.h>
#include <libgen.h>

#include <zlib.h>
#include <glib.h>
#include <rdx.h>

#include <sys/wait.h>
#include <time.h>

/***********************************************************************
 * status codes
 ***********************************************************************/
enum
{
	RESULT_OK,
	RESULT_RUN_ERR,
	RESULT_PARAM_ERR,
	RESULT_HELP
};


/***********************************************************************
 * constants
 ***********************************************************************/

/* maximum line length that can be handled, per RFC 3164 */
#define	MAXLINE			1024

/*
 * see the comments in PmKLogDaemon regarding the issue that glibc
 * does not allow a user-space client to mark a message with kernel
 * facility (LOG_KERN) as needed.  To support passing that through we
 * use a pseudo-facility value and re-map it back.
 */
#define PMLOGDAEMON_LOG_KERN	(LOG_NFACILITIES<<3)

#define PMLOGDAEMON_FILE_ROTATION_PATTERN "%s.%d.gz"


/***********************************************************************
 * globals settings
 ***********************************************************************/
static int			g_showStartInfo;

/* 0 for regular timestamps, 1 for full = RFC 3339 format timestamps */
static int			g_useFullTimeStamps;

/* 0 for no fractional seconds, 1 for 1 digit precision, etc. */
static int			g_timeStampFracSecDigits;

/* 0 for no monotonic seconds, 1 to include monotonic seconds */
static int			g_timeStampMonotonic;

#ifdef PMLOGDAEMON_FEATURE_REMOTE_LOG
/* UDP socket port number, i.e. 514 */
static int			g_port;
#endif

/* path to the unix domain socket = _PATH_LOG = /dev/log */
static char			g_pathLog[ PATH_MAX ];

/***********************************************************************
 * globals
 ***********************************************************************/

/* localHostName is read dynamically */
static char         g_localHostName[ MAXHOSTNAMELEN + 1 ];

static PmLogFile_t  g_logFiles[ PMLOG_MAX_NUM_OUTPUTS ];

static bool         g_captureJSExceptions;

/**********************************************************************
 *	Function declarations
 **********************************************************************/
static int ScanRotatedFile(const char* filename);


/**
 * @brief InitHostName
 */
static void InitHostName(void)
{
	char*	p;

	gethostname(g_localHostName, sizeof(g_localHostName));
	/* trim off the domain name if present */
	p = strchr(g_localHostName, '.');
	if (p != NULL)
	{
		*p = 0;
	}
}


/**
 * @brief ParseRuleFacility
 *
 * "*" => -1, "user" => LOG_USER, etc.
 *
 * @param facilityStr
 * @param facilityP
 *
 * @return true if parsed OK, else false.
 */
bool ParseRuleFacility(const char* facilityStr, int* facilityP)
{
	const int*	nP;

	if (strcmp(facilityStr, "*") == 0)
	{
		*facilityP = -1;
		return true;
	}

	nP = PmLogStringToFacility(facilityStr);
	if (nP != NULL)
	{
		*facilityP = *nP;
		return true;
	}

	*facilityP = -1;
	return false;
}


/**
 * @brief ParseRuleLevel
 *
 * "*" => -1, "err" => LOG_ERR, etc.
 *
 * @param levelStr
 * @param levelP
 *
 * @return true if parsed OK, else false.
 */
bool ParseRuleLevel(const char* levelStr, int* levelP)
{
	const int*	nP;

	if (strcmp(levelStr, "*") == 0)
	{
		*levelP = -1;
		return true;
	}

	nP = PmLogStringToLevel(levelStr);
	if (nP != NULL)
	{
		*levelP = *nP;
		return true;
	}

	*levelP = -1;
	return false;
}


/**
 * @brief GetRuleFacilityStr
 *
 * @param fac
 *
 * @return NULL if not recognized.
 */
static const char* GetRuleFacilityStr(int fac)
{
	const char*	s;

	if (fac == -1)
	{
		return "*";
	}

	s = PmLogFacilityToString(fac);
	return s;
}


/**
 * @brief GetRuleLevelStr
 *
 * -1 => "*", LOG_ERR => "err", etc.
 *
 * @param level
 *
 * @return NULL if not recognized.
 */
static const char* GetRuleLevelStr(int level)
{
	const char*	s;

	if (level == -1)
	{
		return "*";
	}

	s = PmLogLevelToString(level);
	return s;
}


/**
 * @brief FormatPri
 *
 * @param pri
 * @param str
 * @param size
 */
static void FormatPri(int pri, char* str, size_t size)
{
	const char* facStr;
	const char* lvlStr;

	facStr = GetRuleFacilityStr(pri & LOG_FACMASK);
	lvlStr = GetRuleLevelStr(pri & LOG_PRIMASK);

	if ((facStr != NULL) && (lvlStr != NULL))
	{
		mysprintf(str, size, "%s.%s", facStr, lvlStr);
	}
	else
	{
		mysprintf(str, size, "<%d>", pri);
	}
}

/**
 * @brief myremove
 *
 * wrapper around the remove function to provide some error logging
 *
 * @param filename
 *
 * @return
 */
static int myremove(const char* filename) {
	int result;
	int err = 0;
	result = remove(filename);
	if (result < 0)
	{
		err = errno;
		if (errno != ENOENT)
		{
			ErrPrint("myremove: remove error: %s\n",
					strerror(err));
		}
	}
	return err;
}



/**
 * @brief CompressFile
 *
 * compress the given file (using zlib).  The file will be replaced
 * with the compressed file (having the same filename appended with .gz)
 * similarly to how the gzip command works
 *
 * @param infilename
 *
 * @return 0 on success, errno on failure
 */
static int CompressFile(const char *infilename)
{
	char * outfilename = g_strconcat(infilename,".gz",NULL);
	char inbuffer[128];
	int num_read = 0;
	int num_written = 0;
	unsigned long total_read = 0;
	unsigned long total_written = 0;
	int err = 0;
	gzFile * outfile = NULL;
	FILE * infile = NULL;
	if (!outfilename) {
		ErrPrint("CompressFile: Failed to construct compressed filename.\n");
		err = EIO;
		goto Error;
	}
	infile = fopen(infilename, "rb");
	if (!infile) {
		ErrPrint("CompressFile: Failed to open input file.\n");
		err = EIO;
		goto Error;
	}
	outfile = gzopen(outfilename, "wb");
	if (outfile == Z_NULL ) {
		ErrPrint("CompressFile: Failed to create compressed file.\n");
		err = EIO;
		outfile = NULL;
		goto Error;
	}

	while ((num_read = fread(inbuffer, 1, sizeof(inbuffer), infile)) > 0) {
		total_read += num_read;
		num_written = gzwrite(outfile, inbuffer, num_read);
		if (num_written != num_read) {
			ErrPrint("CompressFile: gzwrite error: %s \n", gzerror(outfile, &err));
			goto Error;
		}
		total_written += num_written;
	}
	/* delete old file */
	err = myremove(infilename);

	DbgPrint("CompressFile: Read %lu bytes, Wrote %lu bytes, Compression factor %4.2f%%\n",
			total_read, total_written,
			(1.0-total_written*1.0/total_read)*100.0);
Error:
	if (outfilename)
		free(outfilename);
	if (infile)
		fclose(infile);
	if (outfile)
		gzclose(outfile);

	return err;
}

/**
 * @brief DoRotateLogFile
 *
 * Rotate the specified log set.  It should already have been verified
 * that the base log exists.
 *
 * @param logFileP
 *
 * @return 1 if the rotation was performed, else 0.
 */
static int DoRotateLogFile(PmLogFile_t* logFileP)
{
	int				result;
	int				err;
	char			oldPath[ PATH_MAX ];
	char			newPath[ PATH_MAX ];
	int				i;

	if (logFileP->rotations <= 0)
	{
		/* we require rotations >= 1 */
		ErrPrint("RotateLogFile: invalid number of rotations: %d\n", logFileP->rotations);
		return 0;
	}

	/* rotate the log file set
	   rotations = 1 then { log, log.0.gz }
	   rotations = 2 then { log, log.0.gz, log.1.gz }
	   ... */
	for (i = logFileP->rotations - 1; i > 0; i--)
	{
		mysprintf(oldPath, sizeof(oldPath), PMLOGDAEMON_FILE_ROTATION_PATTERN, logFileP->path, i - 1);
		mysprintf(newPath, sizeof(newPath), PMLOGDAEMON_FILE_ROTATION_PATTERN, logFileP->path, i);
		/* note that rename will replace the old file if present */
		result = rename(oldPath, newPath);
		if (result < 0)
		{
			err = errno;
			if (err != ENOENT)
			{
				DbgPrint("RotateLogFile: rename error: %s\n",
					strerror(err));
			}
		}
	}

	/* the assumption is that the current file is flushed by the rename */
	mysprintf(newPath, sizeof(newPath), "%s.%d", logFileP->path, 0);
	result = rename(logFileP->path, newPath);
	if (result < 0)
	{
		err = errno;
		DbgPrint("RotateLogFile: rename error: %s\n",
			strerror(err));
	}

	if (g_captureJSExceptions) {
		ScanRotatedFile(newPath);
	}

	/* compress the log file
	   TODO: what should we do if it fails to compress the file? */
	CompressFile(newPath);

	return 1;
}

#define ROTATED_LOG_FILE_PATH			"@WEBOS_INSTALL_LOGDIR@/messages.0"
#define LINE_BUFFER_SIZE				1024
#define COMPONENT_BUFFER_SIZE			128
static int
ScanRotatedFile(const char* filename) {
	FILE* f = NULL;
	char line_buffer[LINE_BUFFER_SIZE];
	char component[COMPONENT_BUFFER_SIZE];
	char* backtrace = NULL;
	char* temp = NULL;
	int comp_len = 0;

	/* check if this is /var/log/messages.0 */
	if (strcmp(filename, ROTATED_LOG_FILE_PATH) != 0) {
		return 0;
	}

	f = fopen(filename, "r");
	if (f == NULL) {
		return -1;
	}

	while (1) {
		memset(line_buffer, 0, LINE_BUFFER_SIZE);
		fgets(line_buffer, LINE_BUFFER_SIZE, f);
		if (ferror(f) || (feof(f))) {
			break;
		}

		backtrace = strstr (line_buffer, "EXCEPTION");
	    if (backtrace != NULL) {
	    	memset(component, 0, COMPONENT_BUFFER_SIZE);
	    	temp = strstr(line_buffer, "LunaSysMgrJS");
			if (temp == NULL) {
				continue;
			}

			temp += 15;	/* get to the right place for the component name */
			comp_len = (int)(strchr(temp, ':') - temp);
			strncpy(component, temp, comp_len);
			component[comp_len] = '\0';

			RdxReportMetadata md = create_rdx_report_metadata();
			rdx_report_metadata_set_component(md, component);
			rdx_report_metadata_set_cause(md, "JavaScript Exception");
			rdx_report_metadata_set_detail(md, "Exception");
			rdx_report_metadata_set_payload_filename(md, "exception.txt"); /* defaults to "payload" */
			rdx_make_report(md, backtrace);
			destroy_rdx_report_metadata(md);
		}
	}
	fclose(f);
	return 1;
}

/**
 * @brief RotateLogFile
 *
 * If the specified file is too big to add the specified amount of data
 * according to the maximum size limit, then rotate the file set.
 *
 * @param logFileP
 * @param fd
 * @param numToWrite
 *
 * @return 1 if the rotation was performed, else 0.
 */
static int RotateLogFile(PmLogFile_t* logFileP, int fd, int numToWrite)
{
	int				result;
	int				err;
	struct stat		fdStat;
	int				fileLen;

	if (logFileP->rotations <= 0)
	{
		/* we require rotations >= 1 */
		DbgPrint("RotateLogFile: invalid number of rotations: %d\n", logFileP->rotations);
		return 0;
	}

	result = fstat(fd, &fdStat);
	if (result != 0)
	{
		err = errno;
		DbgPrint("RotateLogFile: fstat error: %s\n",
			strerror(err));
		return 0;
	}

	if (!S_ISREG(fdStat.st_mode))
	{
		DbgPrint("RotateLogFile: not regular file\n");
		return 0;
	}

	fileLen = (int) fdStat.st_size;
	if (fileLen + numToWrite <= logFileP->maxSize)
	{
		return 0;
	}

	result = DoRotateLogFile(logFileP);

	return result;
}

/**
 * @brief WriteToLogFile
 *
 * @param logFileP
 * @param p
 * @param n
 *
 * @return 0 on success else err code.
 */
static int WriteToLogFile(PmLogFile_t* logFileP, const char* p, int n)
{
	int				fd;
	int				err;
	struct flock	fl;
	int				result;
	int				nWritten;
	int				writeErr;
	int				didRotate;

	if ((p == NULL) || (n <= 0))
	{
		/* shouldn't happen, but check anyway */
		DbgPrint("%s: invalid parameter\n",__FUNCTION__);
		return 0;
	}

	didRotate = 0;

Retry:

	fd = open(logFileP->path, O_WRONLY | O_CREAT | O_NOCTTY |
		O_APPEND | O_NONBLOCK, 0644);
	if (fd < 0)
	{
		err = errno;
		ErrPrint("%s: open error: %s\n",__FUNCTION__, strerror(err));
		return err;
	}

	/* get advisory file lock (write => exclusive lock) */
	memset(&fl, 0, sizeof(fl));
	fl.l_type = F_WRLCK;
	result = fcntl(fd, F_SETLKW, &fl);
	if (result != 0)
	{
		err = errno;
		ErrPrint("%s: fcntl F_SETLKW F_WRLCK error: %s\n", __FUNCTION__,
			strerror(err));
	}

	if (didRotate)
	{
		didRotate = 0;
	}
	else
	{
		didRotate = RotateLogFile(logFileP, fd, n);
	}

	writeErr = 0;
	if (!didRotate)
	{
        errno = 0;
        nWritten = write(fd, p, n);
        if (nWritten != n)
        {
            err = errno;
            if (err) {
                ErrPrint("%s: write(%s) error: %d %s\n", __func__, logFileP->path, err, strerror(err));
                writeErr = err;
            } else {
                ErrPrint("%s: write did not complete : %s\n", __func__, logFileP->path);
            }
        }
    }

	/* release advisory file lock */
	memset(&fl, 0, sizeof(fl));
	fl.l_type = F_UNLCK;
	result = fcntl(fd, F_SETLKW, &fl);
	if (result != 0)
	{
		err = errno;
		ErrPrint("%s: fcntl F_SETLKW F_UNLCK error: %s\n", __FUNCTION__,
			strerror(err));
	}

	/* close the file, which will sync (flush) it */
	close(fd);

	if (didRotate)
	{
		goto Retry;
	}

	return writeErr;
}


/**
 * @brief ForceRotateLogFile
 *
 * @param logFileP
 *
 * @return 0 on success else err code.
 */
static int ForceRotateLogFile(PmLogFile_t* logFileP)
{
	int				result;
	int				err;
	struct stat		fileStat;

	result = stat(logFileP->path, &fileStat);
	if (result != 0)
	{
		err = errno;
		DbgPrint("ForceRotateLogFile: stat error: %s\n",
			strerror(err));
		return 0;
	}

	if (!S_ISREG(fileStat.st_mode))
	{
		DbgPrint("ForceRotateLogFile: not regular file\n");
		return 0;
	}

	result = DoRotateLogFile(logFileP);

	return result;
}


/**
 * @brief MatchOutputRule
 *
 * @param ruleP
 * @param pri
 * @param programName
 *
 * @return true if the specified message attributes match the specified
 * rule.
 */
static bool MatchOutputRule(const PmLogRule_t* ruleP, int pri,
	const char* programName)
{
	int		fac;
	int		lvl;

	fac = pri & LOG_FACMASK;
	lvl = pri & LOG_PRIMASK;

	if (ruleP->facility != -1)
	{
		if (ruleP->facility != fac)
		{
			return false;
		}
	}

	if (ruleP->level == -1)
	{
		if (ruleP->levelInvert)
		{
			return false;
		}
	}
	else
	{
		if (ruleP->levelInvert)
		{
			if (ruleP->level >= lvl)
			{
				return false;
			}
		}
		else
		{
			/*
			 * If the rule specified a level, it means match
			 * that level or higher priority. But remember that
			 * higher priority means lower numeric value.
			 */
			if (ruleP->level < lvl)
			{
				return false;
			}
		}
	}

	if (ruleP->program != NULL)
	{
		if (programName == NULL)
		{
			return false;
		}

		if (strcmp(ruleP->program, programName) != 0)
		{
			return false;
		}
	}

	return true;
}

/* Forward Declaration */
static void LogFileKillRotations(PmLogFile_t* logFileP, int start);

/**
 * @brief OutputMessage
 *
 * @param contextName
 * @param pri
 * @param programName
 * @param msg
 */
static void OutputMessage(
	const PmLogContextConf_t* contextConfP, int pri,
	const char* programName, const char* msg)
{
	bool						wantOutput[ g_numOutputs ];
	int							i;
	const PmLogRule_t*			ruleP;
	PmLogFile_t*				logFileP;

	if (contextConfP == NULL) {
		ErrPrint("%s: contextConfP is null\n", __FUNCTION__);
		return;
	}

	for (i = 0; i < g_numOutputs; i++)
	{
		wantOutput[ i ] = false;
	}

	/* determine which outputs to target based on the context rules */
	for (i = 0; i < contextConfP->numRules; i++)
	{
		ruleP = &contextConfP->rules[ i ];
		if (MatchOutputRule(ruleP, pri, programName))
		{
			g_assert(ruleP->outputIndex >= 0);
			g_assert(ruleP->outputIndex < g_numOutputs);
			if (ruleP->omitOutput)
				wantOutput[ ruleP->outputIndex ] = false;
			else
				wantOutput[ ruleP->outputIndex ] = true;
		}
	}

	/* output to the specified targets */
	for (i = 0; i < g_numOutputs; i++)
	{
		logFileP = &g_logFiles[ i ];
		if (wantOutput[ i ])
		{
			int err_code = WriteToLogFile(logFileP, msg, strlen(msg));

            /* out of space.. clear it and report it */
            if (err_code == ENOSPC) {
                ErrPrint("%s: Out of space! making room: %d\n", __func__, err_code);
                gchar *file_name = NULL;
                GError *gerr = NULL;
                if (!g_spawn_command_line_sync("@WEBOS_INSTALL_DATADIR@/PmLogDaemon/show_disk_usage.sh @WEBOS_INSTALL_LOGDIR@", &file_name, NULL, NULL, &gerr)) {
                    ErrPrint("%s: spawn failed: %s\n", __func__, gerr->message);
                    g_error_free(gerr);
                } else {
                    g_return_if_fail(file_name);
                    g_strstrip(file_name);

                    /* clear some space */
                    int j;
                    for (j = 0; j < g_numOutputs; j++)
                        LogFileKillRotations(&g_logFiles[j], 0);

                    RdxReportMetadata md = create_rdx_report_metadata();
                    rdx_report_metadata_set_component(md, "syslog");
                    rdx_report_metadata_set_cause(md, "@WEBOS_INSTALL_LOGDIR@ full");
                    rdx_report_metadata_set_detail(md, "@WEBOS_INSTALL_LOGDIR@ full");
                    if (!rdx_make_report_from_file(md, file_name)) {
                        /* more aggressive cleanup */
                        ErrPrint("%s: couldn't create low disk space report after clearing logs.. Kill 'em all!\n", __func__);
                        system("/bin/rm -rf @WEBOS_INSTALL_LOGDIR@/* @WEBOS_INSTALL_LOGDIR@/.*");
                        system("/usr/bin/pkill -SIGHUP rdxd"); /* restart rdxd */
                        if (!rdx_make_report_from_file(md, file_name)) {
                            ErrPrint("%s: still couldnt make report after nuking @WEBOS_INSTALL_LOGDIR@!\n", __func__);
                        }
                    }
                    destroy_rdx_report_metadata(md);
                }
                g_remove(file_name);
                g_free(file_name);
            }
		}
	}
}


/**
 * @brief ParseMsgProgram
 *
 * If the message came from a syslog call, it should be of the form:
 * 	<progname> [ '[' <pid> ']' ] ':' ' '
 *
 * If this is matched, return the address of the character past the ' ',
 * else return NULL.
 *
 * @param msg the message to parse
 * @param programFull
 * @param programFullBuffSize
 * @param nameLenP
 * @param programName
 * @param programNameBuffSize
 *
 * @return if a match was made, the program name is returned in programName,
 * otherwise it should be left empty.
 */
static const char* ParseMsgProgram(const char* msg,
	char* programFull, size_t programFullBuffSize, size_t* nameLenP,
	char* programName, size_t programNameBuffSize)
{
	const char* s;
	size_t		nameLen;
	size_t		fullLen;

	programFull[ 0 ] = 0;
	programName[ 0 ] = 0;
	*nameLenP = 0;

	s = msg;

	/* span characters not including '[', ':', and whitespace */
	nameLen = 0;
	while ((*s != 0) && (*s != '[') && (*s != ':') && (!isspace(*s)))
	{
		nameLen++;
		s++;
	}

	if (nameLen == 0)
	{
		return NULL;
	}

	if (*s == '[')
	{
		s++;
		while (isdigit(*s))
		{
			s++;
		}
		if (*s == ']')
		{
			s++;
		}
	}

	if (*s != ':')
	{
		return NULL;
	}
	s++;

	if (*s != ' ')
	{
		return NULL;
	}
	s++;

	fullLen = s - msg;

	if (fullLen >= programFullBuffSize)
	{
		/* overflow */
		return NULL;
	}

	memcpy(programFull, msg, fullLen);
	programFull[ fullLen ] = 0;

	*nameLenP = nameLen;

	if (nameLen >= programNameBuffSize)
	{
		/* name buff overflow! */
		nameLen = programNameBuffSize - 1;
	}

	memcpy(programName, msg, nameLen);
	programName[ nameLen ] = 0;

	return s;
}


/**
 * @brief ParseMsgPidTid
 *
 * If PmLogLib is set to log process/thread IDs, it should be of the form:
 * 	'[' <pid> [ ':' <tid> ] ']' ':' ' '
 *
 * @param msg the message to parse
 *
 * @return if this is matched, return the address of the character past the ' ',
 * else return NULL.
 */
static const char* ParseMsgPidTid(const char* msg)
{
	const char* s;

	s = msg;

	if (*s != '[')
	{
		return NULL;
	}
	s++;

	if (!isdigit(*s))
	{
		return NULL;
	}
	s++;

	while (isdigit(*s))
	{
		s++;
	}

	if (*s == ':')
	{
		s++;
		if (!isdigit(*s))
		{
			return NULL;
		}
		s++;

		while (isdigit(*s))
		{
			s++;
		}
	}

	if (*s != ']')
	{
		return NULL;
	}
	s++;

	if (*s != ':')
	{
		return NULL;
	}
	s++;

	if (*s != ' ')
	{
		return NULL;
	}
	s++;

	return s;
}


/**
 * @brief ParseMsgContext
 *
 * If the message came from a PmLogLib call that specified a context,
 * it should be of the form:
 * 	'{' <contextName '}' ':' ' '
 *
 * If a match was made, the context name is returned in contextName,
 * otherwise it should be left empty.
 *
 * @param msg the message
 * @param contextName  the context name to write
 * @param contextNameBuffSize  the size of the context name buffer
 *
 * @return the address of the character past the ' ' if this is matched, otherwise return NULL.
 */
static const char* ParseMsgContext(const char* msg, char* contextName,
	size_t contextNameBuffSize)
{
	const char* s;
	size_t		i;

	contextName[ 0 ] = 0;

	s = msg;

	if (*s != '{')
	{
		return NULL;
	}
	s++;

	/* span characters that are allowed for context names
	 * see PmLogLib for definition */
	i = 0;
	while ((*s != 0) && (*s != '}') && (!isspace(*s)) &&
		(isalnum(*s) || (*s == '.') || (*s == '_')))
	{
		i++;
		s++;
	}

	if (i == 0)
	{
		return NULL;
	}

	if (*s != '}')
	{
		return NULL;
	}
	s++;

	if (*s != ':')
	{
		return NULL;
	}
	s++;

	if (*s != ' ')
	{
		return NULL;
	}
	s++;

	if (i >= contextNameBuffSize)
	{
		/* context buff overflow! */
		i = contextNameBuffSize - 1;
	}

	memcpy(contextName, msg + 1, i);
	contextName[ i ] = 0;

	return s;
}




/**
 * @brief HandleLogCommand
 * A command handler used to handle internal log commands (like rotate and dump).
 *
 * @param msg the message
 *
 * @return true iff the message was a command and it was handled.
 */
static bool HandleLogCommand(const char* msg)
{
	const char*  kLogCmdPrefix    = "!log ";
	const size_t kLogCmdPrefixLen = 5;
	PmLogFile_t* logFileP;

	if (strncmp(msg, kLogCmdPrefix, kLogCmdPrefixLen) != 0)
	{
		return false;
	}

	msg += kLogCmdPrefixLen;

	if (strcmp(msg, "rotate") == 0)
	{
		DbgPrint("HandleLogCommand: forcing rotation of main log\n");
		logFileP = &g_logFiles[ 0 ];
		(void) ForceRotateLogFile(logFileP);
		return true;
	}

	return false;
}

/**
 * @brief getMonotonicTime
 *
 * Get the current monotonic time in seconds
 *
 * @return -1 on error, the monotonic time otherwise
 */
static __time_t getMonotonicTime() {
	int result = 0;
	struct timespec ts;
	result = clock_gettime(CLOCK_MONOTONIC,&ts);
	if (result != 0) {
		ErrPrint("%s: Problem reading time", __FUNCTION__);
		return -1;
	}
	return ts.tv_sec;
}

/**
 * @brief FlushMessage
 *
 * Flush the given message.  This just calls OutputMessage
 *
 * @param msg The message to flush
 * @param data the context to flush under
 */
void FlushMessage(const char* msg, gpointer data) {
	DbgPrint("%s: called with msg=%s\n", __FUNCTION__, msg);
	const PmLogContextConf_t*	contextConfP = data;
	gchar** tokens 		= g_strsplit(msg,"/", 3);
	/* TODO: report corrupted buff msg, or print err msg */
	if (tokens == NULL) {
		/* no buffer message */
		DbgPrint("%s: No buffer message\n", __FUNCTION__);
	} else if (tokens[0] && tokens[1] && tokens[2]) {
		/* TODO: check size of tokens */
		char *p;
		errno=0;
		int pri = strtol(tokens[0], &p, 10);

		if ((errno != 0) || ((*p) != '\0')) {
			ErrPrint("%s: parse error on pri token\n", __FUNCTION__);
			goto error;
		}
		gchar* programName 	= tokens[1];
		gchar* outMsg 		= tokens[2];

		OutputMessage(contextConfP, pri, programName, outMsg);
	} else {
		/* corrupted buffer message */
		DbgPrint("%s: Corrupted buffer message\n", __FUNCTION__);
	}
error:
	if (tokens)
		g_strfreev(tokens);

}

/**
 * @brief MakeMessageTimestamp
 *
 * Creates the timestamp string that is the prefix to output messages.
 *
 * @return pointer to new gchar* containing timestamp
 */
static gchar* MakeMessageTimestamp() {

	struct timeval	nowTv;
	time_t			now;
	struct tm		nowTm;
	char			fracSecStr[ 16 ];
	GString*		timeStamp = NULL;
	__time_t mono = -1;

	memset(&nowTv, 0, sizeof(nowTv));
	(void) gettimeofday(&nowTv, NULL);
	now = nowTv.tv_sec;

	if (g_useFullTimeStamps)
	{
		/*  Generate the timestamp => "1985-04-12T23:20:50.52Z" */
		memset(&nowTm, 0, sizeof(nowTm));
		(void) gmtime_r(&now, &nowTm);

		fracSecStr[ 0 ] = 0;
		if (g_timeStampFracSecDigits > 0)
		{
			mysprintf(fracSecStr, sizeof(fracSecStr),
					".%06ld", nowTv.tv_usec);
			fracSecStr[ 1 + g_timeStampFracSecDigits ] = 0;
		}


		timeStamp = g_string_sized_new(40);
		g_string_printf(timeStamp,
				"%04d-%02d-%02dT%02d:%02d:%02d%sZ",
				1900 + nowTm.tm_year, 1 + nowTm.tm_mon,	nowTm.tm_mday,
				nowTm.tm_hour, nowTm.tm_min, nowTm.tm_sec, fracSecStr);
	}
	else
	{
		/*
		 * Generate the timestamp. ctime => "Wed Jun 30 21:49:08 1993\n"
		 * Note: glibc uses strftime "%h %e %T" using C locale 
		 */
		timeStamp = g_string_new_len(ctime(&now) + 4, 15);
	}

	/* append the monotonic time */
	if (g_timeStampMonotonic) {
		mono = getMonotonicTime();
		if (mono != -1)
			g_string_append_printf(timeStamp, " [%ld]", mono);
	}

	return g_string_free(timeStamp,FALSE);
}

/**
 * @brief FlushNotMe
 *
 * This flushes the RB if the context is not me.  The point of this
 * is that it is called on every contexts when a flush is to be done.
 * We exclude "me" since it will be done last.
 *
 * @param value pointer to a context that may be flushed
 * @param data pointer to the context that is not to be flushed, aka "me"
 * @param key unused
 *
 * @return
 */
gboolean FlushNotMe(gpointer key, gpointer value, gpointer data) {
	PmLogContextConf_t*	keyContextP = value;
	const PmLogContextConf_t*	me = data;

	if (keyContextP == me) {
		/* Don't flush me. It will be done last so I show up recently in log */
		DbgPrint("%s: %s will be flushing last, skipping\n",__FUNCTION__, keyContextP->contextName);
	} else if ( keyContextP->rb) {
		/* have RB, need to flush */
		DbgPrint("%s: %s is now flushing...\n",__FUNCTION__, keyContextP->contextName);

		if (!(keyContextP->rb->isEmpty)) {

			gchar * timeStamp = MakeMessageTimestamp();
			char			priStr[ 20 ];
			/* look up facility + priority name from pri */
			FormatPri(LOG_SYSLOG | LOG_INFO, priStr, sizeof(priStr));
			gchar * outMsg = g_strdup_printf("%s %s %s pmsyslogd: {%s}: ------ Flushing ring buffer for context %s ------\n",
                    timeStamp,
                    g_localHostName,
                    priStr,
                    keyContextP->contextName,
                    me->contextName);

			g_free(timeStamp);
			OutputMessage(keyContextP, LOG_SYSLOG | LOG_INFO, "pmsyslogd", outMsg);
            g_free(outMsg);

			RBFlush(keyContextP->rb, FlushMessage, keyContextP);

			timeStamp = MakeMessageTimestamp();
			outMsg = g_strdup_printf("%s %s %s pmsyslogd: {%s}: ------ Done flushing ------\n",
                    timeStamp,
                    g_localHostName,
                    priStr,
                    keyContextP->contextName);
			OutputMessage(keyContextP, LOG_SYSLOG | LOG_INFO, "pmsyslogd", outMsg);

			g_free(timeStamp);
			g_free(outMsg);
		}
	} else {
		/* no RB, keep going */
		DbgPrint("%s: %s doesnt have ring buffer, not flushing\n",__FUNCTION__, keyContextP->contextName);
	}
	return FALSE;
}


/**
 * @brief LogMessage
 * Log the message
 *
 * @param pri priority
 * @param msg message to log
 */
static void LogMessage(int pri, const char* msg)
{
	int				msgLen;
	gchar*          timeStamp = NULL;
	char			priStr[ 20 ];
	GString*		outMsg = g_string_sized_new( MAXLINE + 1 );
	char			msgProgram[ 256 ];
	char			programName[ PMLOG_PROGRAM_MAX_NAME_LENGTH + 1 ];
	char			contextName[ PMLOG_MAX_CONTEXT_NAME_LEN + 1 ];
	const char*		msgLeft;
	const char*		msgCurr;
	const char*		msgNext;
	size_t			msgProgramNameLen;


	timeStamp = MakeMessageTimestamp();

	/*
	 * Remove timestamp prefix if present. Local messages should have this, remote may not.
	 * Check for RFC 3164 timestamp  0123456789ABCDEF0 "Mmm dd hh:mm:ss " and remove it 
	 */
	msgLen = strlen(msg);
	if ((msgLen >= 16) &&
		(msg[ 3 ] == ' ') &&
		isdigit(msg[ 5 ]) &&
		(msg[ 6 ] == ' ') &&
		isdigit(msg[ 8 ]) &&
		(msg[ 9 ] == ':') &&
		isdigit(msg[ 10 ]) &&
		isdigit(msg[ 11 ]) &&
		(msg[ 12 ] == ':') &&
		isdigit(msg[ 13 ]) &&
		isdigit(msg[ 14 ]) &&
		(msg[ 15 ] == ' '))
	{
		msg += 16;
		msgLen -= 16;
	}

	/* look up facility + priority name from pri */
	FormatPri(pri, priStr, sizeof(priStr));

	g_string_printf(outMsg, "%s %s %s ", timeStamp,
		g_localHostName, priStr);

	g_free(timeStamp);

	msgProgram[ 0 ] = 0;
	programName[ 0 ] = 0;
	contextName[ 0 ] = 0;

	/*
	 * msgLeft is what will actually be written to the file (possibly
	 * after stripping some stuff off from msg prefix) 
	 */
	msgLeft = msg; // eg "progName: {contextName}: rest of msg..."

	/* parse off program identifier prefix */
	msgNext = ParseMsgProgram(msgLeft, msgProgram, sizeof(msgProgram),
		&msgProgramNameLen, programName, sizeof(programName));
	if (msgNext != NULL)
	{
		msgLeft = msgNext; /* eg "{contextName}: rest of msg..." */
	}

	/* msgCurr is where we're at in parsing */
	msgCurr = msgLeft;

	/* parse off PmLogLib pid/tid prefix */
	msgNext = ParseMsgPidTid(msgCurr);
	if (msgNext != NULL)
	{
		/* integrate into msgProgram */
		mysprintf(msgProgram + msgProgramNameLen,
			sizeof(msgProgram) - msgProgramNameLen, "%.*s",
			msgNext - msgCurr, msgCurr);

		msgLeft = msgNext;
		msgCurr = msgNext;
	}

	/* parse off PmLogLib context identifier prefix (if present) */
	msgNext = ParseMsgContext(msgCurr, contextName, sizeof(contextName));
	if (msgNext != NULL)
	{
		msgCurr = msgNext;
	}

	if (HandleLogCommand(msgCurr))
	{
		return;
	}

	outMsg = g_string_append(outMsg, msgProgram); /* e.g "PmWanDaemon: \0" */
	outMsg = g_string_append(outMsg, msgLeft); /* "{wan.mgr}: my message..." */
	outMsg = g_string_append(outMsg, "\n"); /* e.g "2008-12-08T12:17:12.824279Z [1824] castle user.info uploadd: {uploadd}: msg... \n" */


	PmLogContextConf_t*	contextConfP = NULL;

	/* look up the specified context */
	if ((contextName[ 0 ] != 0))
		contextConfP = g_tree_lookup(g_contextConfs, contextName);

	/* default to default context */
	if (contextConfP == NULL)
	{
		contextConfP = g_tree_lookup(g_contextConfs, kPmLogDefaultContextName);
		if (contextConfP == NULL) {
			ErrPrint("%s, default context not found!\n", __FUNCTION__);
			return;
		}
	}

	/* Has ring buffer */
	if (contextConfP->rb) {
		DbgPrint("%s: %s has RB\n", __FUNCTION__, contextConfP->contextName);
		int lvl = pri & LOG_PRIMASK;
		if (lvl <= contextConfP->rb->flushLevel) {
			DbgPrint("%s: %s Flushing!\n", __FUNCTION__, contextConfP->contextName);
			g_tree_foreach(g_contextConfs, FlushNotMe, contextConfP);

			timeStamp = MakeMessageTimestamp();
			char priStr2[20];
			FormatPri(LOG_SYSLOG | LOG_INFO, priStr2, sizeof(priStr2));
			gchar * flushMsg = g_strdup_printf("%s %s %s pmsyslogd: {%s}: ------ Flushing ring buffer for %s message ------\n", 
                    timeStamp,
                    g_localHostName,
                    priStr2,
                    contextConfP->contextName,
                    priStr);
			g_free(timeStamp);
			OutputMessage(contextConfP, pri, "pmsyslogd", flushMsg);

			/* Flush */
			RBFlush(contextConfP->rb, FlushMessage, contextConfP);
			OutputMessage(contextConfP, pri, programName, outMsg->str);
            g_free(flushMsg);

			timeStamp = MakeMessageTimestamp();
			flushMsg = g_strdup_printf("%s %s %s pmsyslogd: {%s}: ------ Done flushing ------\n",
                    timeStamp,
                    g_localHostName,
                    priStr2,
                    contextConfP->contextName);
			OutputMessage(contextConfP, pri, "pmsyslogd", flushMsg);
			g_free(timeStamp);
			g_free(flushMsg);

		} else {
			DbgPrint("%s: %s buffering!\n", __FUNCTION__, contextConfP->contextName);
			/* buffer */
			char buffMsg[contextConfP->rb->bufferSize];
			snprintf(buffMsg, sizeof(buffMsg) - 1, "%d/%s/%s", pri, programName, outMsg->str);
			buffMsg[sizeof(buffMsg) -1 ] = '\0';
			RBWrite(contextConfP->rb, buffMsg, strlen(buffMsg) + 1);
		}
	} else {
		OutputMessage(contextConfP, pri, programName, outMsg->str);
	}

	g_string_free(outMsg, true);

#ifdef RDX_LOG_REPORTING
    /* RDX report */
    int i=0;
    if ((pri & LOG_PRIMASK) <= LOG_CRIT) {
        const char * black_list[] = { "rdxd", "uploadd", "pmsyslogd", "upstart", NULL };
        for (i=0; black_list[i] != NULL; i++) {
            if (strcmp(black_list[i], programName) == 0)
                return;
        }

        RdxReportMetadata md = create_rdx_report_metadata();
        rdx_report_metadata_set_component(md, "syslog");
        const char * cause;
        switch ((pri & LOG_PRIMASK)) {
            case LOG_EMERG:
                cause = "LOG_EMERG";
                break;
            case LOG_ALERT:
                cause = "LOG_ALERT";
                break;
            case LOG_CRIT:
                cause = "LOG_CRIT";
                break;
            case LOG_ERR:
                cause = "LOG_ERR";
                break;
            case LOG_WARNING:
                cause = "LOG_WARNING";
                break;
            case LOG_NOTICE:
                cause = "LOG_NOTICE";
                break;
            case LOG_INFO:
                cause = "LOG_INFO";
                break;
            case LOG_DEBUG:
                cause = "LOG_DEBUG";
                break;
            default:
                cause = "UNKNOWN";
        }
        rdx_report_metadata_set_cause(md, cause);
        rdx_report_metadata_set_detail(md, programName);
        rdx_make_report(md, msg);
        destroy_rdx_report_metadata(md);
    }
#endif
}


/**
 * @brief ProcessMessage
 *
 * Message processor, this is called on each message read
 * off of the /dev/log socket; it will actually parse the
 * message to calculate the priority and recreate the log
 * body to contain with printable characters.  Afterwhich
 * it will log the message.
 *
 * @param buff the message
 * @param buffLen the length of the message
 */
static void ProcessMessage(const char* buff, int buffLen)
{
	int				pri;
	const char*		in;
	char			line[ MAXLINE + 1 ];
	char*			out;
	unsigned char	c;

	/*
	 * As we are using a datagram socket, we know that buff is a
	 * complete message that is a null-terminated string.
	 * The caller has already verified that, so we can ignore
	 * the specified length here and just look for the terminator.
	 * Note: If there were embedded NUL characters in
	 * the data that will cause the message to be truncated. 
	 */
	(void) &buffLen;

	pri = LOG_USER | LOG_NOTICE;

	in = buff;

	/* If string starts with "<ddd>" parse the priority */
	if (*in == '<')
	{
		in++;
		pri = 0;
		while (isdigit(*in))
		{
			pri = pri * 10 + *in - '0';
			in++;
		}

		if (*in == '>')
		{
			in++;
		}
	}

	if ((pri & LOG_FACMASK) == PMLOGDAEMON_LOG_KERN)
	{
		pri = (pri & (~LOG_FACMASK)) | LOG_KERN;
	}

	if (pri & ~(LOG_FACMASK | LOG_PRIMASK))
	{
		pri = LOG_USER | LOG_NOTICE;
	}

	out = line;
	while ((c = *in++) != 0)
	{
		if (out >= &line[ sizeof(line) - 1 ] )
		{
			break;
		}

		if ((c == '\n') || (c == 127))
		{
			*out++ = ' ';
		}
		else if (c < 0x20)
		{
			if (out + 1 >= &line[ sizeof(line) - 1 ] )
			{
				break;
			}

			/*
			 * escape control characters as printable
			 * 0x07 => ^G, 0x08 => ^H, 0x09 => ^I, etc
			 */
			*out++ = '^';
			*out++ = c ^ 0x40;
		}
		else
		{
			*out++ = c;
		}
	}
	*out = 0;
	LogMessage(pri, line);
}


/**
 * @brief SysLogMessage
 * Wrapper around the LogMessage command to provide
 * formated arguments.
 * Note this must be called with printf type arguments
 *
 * @param fmt the format string
 * @param ... optional additional arguments
 */
static void SysLogMessage(const char* fmt, ...)
	 __attribute__((format(printf, 1, 2)));

static void SysLogMessage(const char* fmt, ...)
{
	va_list 	args;
	char		msg[ 512 ];

	va_start(args, fmt);

	(void) vsnprintf(msg, sizeof(msg), fmt, args);

	va_end(args);

	LogMessage(LOG_SYSLOG | LOG_INFO, msg);
}

static GMainLoop * mainLoop = NULL;

/**
 * @brief QuitSysLogD
 * Flush all log buffers and quit.  This method is intended to be called
 * as a signal handler
 *
 * @param sig the signal to handle
 */
static void QuitSysLogD(int sig)
{
	/* exit based on external signal */
	SysLogMessage("PmLogDaemon: exiting");
	g_main_loop_quit(mainLoop);
}


/**
 * @brief LogConfig
 *
 * Used to log the configuration for debugging purposes.
 *
 * This is a GTraverseFunc (see glib's Balanced Binary Trees), it is passed the key and value
 * of each node, together with user_data parameter passed to g_tree_traverse().  If the function
 * returns TRUE, the traversal is stopped;  Currently it will never stop.
 *
 * @param key a key of a GTree node
 * @param value the value corresponding to the key
 * @param data user data passed to g_tree_traversal
 *
 * @return TRUE to stop the traversal; currently it always returns FALSE
 */
static gboolean LogConfig(gpointer key, gpointer value, gpointer data) {
	const PmLogContextConf_t*	contextP = value;
	gchar * name = (gchar*)key;
	int j;

	const PmLogFile_t*	outputP;
	const PmLogRule_t*			ruleP;
	SysLogMessage("PmLogDaemon: Context name=%s", name);
	for (j = 0; j < contextP->numRules; j++)
	{
		ruleP = &contextP->rules[ j ];

		outputP = &g_outputConfs[ ruleP->outputIndex ];

		SysLogMessage("PmLogDaemon:   Rule %s.%s%s.%s => %s%s",
				GetRuleFacilityStr(ruleP->facility),
				ruleP->levelInvert ? "!" : "",
				GetRuleLevelStr(ruleP->level),
				(ruleP->program == NULL) ? "*" : ruleP->program,
				ruleP->omitOutput ? "-" : "",
				outputP->outputName
			     );
	}
	/* return true to stop the traversal */
	return FALSE;

}

/**
 * @brief LogConfigInfo
 *
 * For status reporting purposes, log out configuration information.
 * It accomplishes this by calling LogConfig on every node in the configuration
 * tree.
 *
 * @see LogConfig
 */
static void LogConfigInfo(void)
{
	const PmLogFile_t*	outputP;
	int					i;

	for (i = 0; i < g_numOutputs; i++)
	{
		outputP = &g_outputConfs[ i ];

		SysLogMessage("PmLogDaemon: Output name=%s path=%s size=%d rot=%d", 
			outputP->outputName,
            outputP->path,
            outputP->maxSize,
			outputP->rotations);
	}

	g_tree_foreach(g_contextConfs, LogConfig, NULL);
}

/**
 * @brief LogFileKillRotations
 *
 * delete the rotation files at and after the given index
 *
 * e.g
 * messages          index: 0
 * messages.0.gz     index: 1
 * messages.1.gz     index: 2
 * messages.2.gz     index: 3
 * messages.3.gz     index: 4
 * messages.4.gz     index: 5
 *
 * @param logFileP
 * @param start starting index to delete, see example above
 */
static void
LogFileKillRotations(PmLogFile_t* logFileP, int start)
{
    int r = 0;
	for (r = start; r < PMLOG_MAX_NUM_ROTATIONS; r++)
	{
        gchar * rotation_file = r ?
            g_strdup_printf(PMLOGDAEMON_FILE_ROTATION_PATTERN, logFileP->path, r - 1) :
            g_strdup(logFileP->path);

        g_remove(rotation_file);
        g_free(rotation_file);
    }
}


/**
 * @brief LogFileInit
 * Constructor for the logFileP; copy variables from confP and initialize
 *
 * @param logFileP logfile to initialize
 * @param confP source of initial data to copy from.
 */
static void LogFileInit(PmLogFile_t* logFileP, const PmLogFile_t* confP)
{
	/* copy the fields to this struct for convenience */
	logFileP->outputName    = confP->outputName;
	logFileP->path          = confP->path;
	logFileP->maxSize       = confP->maxSize;
	logFileP->rotations     = confP->rotations;

    /* make sure there are not stale rotation files around */
    LogFileKillRotations(logFileP, logFileP->rotations + 1);
}


/**
 * @brief HandleNewLog
 *
 * Called by Glib's mainloop when there is data in the channel
 * to read.  In  this case this is called when someone has written
 * to the unix domain socket /dev/log
 *
 * @param source the channel (/dev/log) that has data to read
 * @param condition
 * @param data
 *
 * @return
 */
gboolean HandleNewLog(GIOChannel *source,GIOCondition condition, gpointer data) {
	char buff[MAXLINE+1];
	ssize_t bytes;
	int sock_fd = g_io_channel_unix_get_fd(source);

	if ((condition & G_IO_IN) || (condition & G_IO_PRI)) {
		bytes = recv(sock_fd, buff, sizeof(buff) - 1, 0);
		if (bytes <= 0) {
			ErrPrint("%s: recv returned %d", __FUNCTION__, bytes);
			goto error;
		}

		if (bytes) {
			buff[bytes] = '\0';
			ProcessMessage(buff, bytes);
		}
	} else {
		ErrPrint("%s: unexpected watch event condition: %d\n", __FUNCTION__, condition);
	}
error:
	/* TODO: should this ever return FALSE, to close the channel? */
	return TRUE;
}


/**
 * @brief RunSysLogD
 * Run the actual syslogdaemon as a daemon; Register a listener on the
 * /dev/log unix domain socket for locally generated log
 * messages.
 *
 * @return RESULT_OK if we were able to listen on the socket, error code otherwise
 */
static int RunSysLogD(void)
{
	PmLogFile_t*        logFileP;
	struct sockaddr_un  sunx;
	int                 sock_fd;
	int                 err;
	int                 result;
	int                 i;
	GIOChannel*         gioch;

	(void) signal(SIGINT, QuitSysLogD);
	(void) signal(SIGTERM, QuitSysLogD);
	(void) signal(SIGQUIT, QuitSysLogD);

	(void) signal(SIGHUP, SIG_IGN);
	(void) signal(SIGCHLD, SIG_IGN);

	InitHostName();

	for (i = 0; i < g_numOutputs; i++)
	{
		logFileP = &g_logFiles[ i ];
		LogFileInit(logFileP, &g_outputConfs[ i ]);
	}

	/* clean up before start */
	(void) unlink(g_pathLog);

	mainLoop = g_main_loop_new(NULL, FALSE);
	if (mainLoop == NULL) goto error;

	/* create socket listener */
	memset(&sunx, 0, sizeof(sunx));
	sunx.sun_family = AF_UNIX;
	(void) strncpy(sunx.sun_path, g_pathLog, sizeof(sunx.sun_path)-1);

	sock_fd = socket(AF_UNIX, SOCK_DGRAM, 0);
	if (sock_fd < 0)
	{
		err = errno;
		ErrPrint("RunSysLogD: socket error: %s\n", strerror(err));
		return RESULT_RUN_ERR;
	}

	result = bind(sock_fd, (struct sockaddr *) &sunx,
		sizeof(sunx.sun_family) + strlen(sunx.sun_path));
	if (result < 0)
	{
		err = errno;
		ErrPrint("RunSysLogD: bind error: %s\n", strerror(err));
		return RESULT_RUN_ERR;
	}

	result = chmod(g_pathLog, 0666);
	if (result < 0)
	{
		err = errno;
		ErrPrint("RunSysLogD: chmod error: %s\n", strerror(err));
		return RESULT_RUN_ERR;
	}

	gioch = g_io_channel_unix_new(sock_fd);
	if (gioch == NULL) {
		ErrPrint("%s: channel error using fd: %d\n", __FUNCTION__, sock_fd);
		return RESULT_RUN_ERR;
	}
	g_io_add_watch(gioch, G_IO_IN, HandleNewLog, NULL);
	g_io_channel_unref(gioch);

	/* Run the main loop */
	SysLogMessage("PmLogDaemon: started");

	if (g_showStartInfo)
	{
		LogConfigInfo();
	}

	g_captureJSExceptions = false;
	/* Before initializing, check to see that we are pointed to the QA server so we don't overload production with JS crashes */
	if (g_file_test ("/usr/share/omadm/internal", G_FILE_TEST_EXISTS)) {
		SysLogMessage("Pointed to QA, enabling JS RDX scrape");
		g_captureJSExceptions = true;
	}

	g_main_loop_run(mainLoop);
	g_main_loop_unref(mainLoop);

error:

	(void) unlink(g_pathLog);

	/* Clean up our pid file.  Not necessary, but nice to have */
	UnlockProcess();

	exit(EXIT_SUCCESS);

	return RESULT_OK;
}


/**
 * @brief InitSettings
 * Initialize the settings of this configuration
 */
static void InitSettings(void)
{
	g_showStartInfo = 0;
	g_useFullTimeStamps = 0;
	g_timeStampFracSecDigits = 0;

	mystrcpy(g_pathLog, sizeof(g_pathLog), _PATH_LOG);

	g_numOutputs = 0;
	g_numContexts = 0;
}


/**
 * @brief ParseParams
 * Parse the command line parameters.
 *
 * @param argc number of arguments
 * @param argv array of arguements
 *
 * @return Return result code.
 */
static int ParseParams(int argc, char* argv[])
{
	int ret = RESULT_OK;
	GOptionEntry entries[] =
	{
		{ "fractional", 'f', 0, G_OPTION_ARG_INT, &g_timeStampFracSecDigits,
			"Specify timestamp seconds decimal precision (0..6)", "N"},
		{ "verbose", 'v', 0, G_OPTION_ARG_NONE, &g_showStartInfo,
			"Be verbose", NULL },
		{ "longtime", 'z', 0, G_OPTION_ARG_NONE, &g_useFullTimeStamps,
			"Use full RFC 3339 format timestamps", NULL },
		{ "monotonic", 'm', 0, G_OPTION_ARG_NONE, &g_timeStampMonotonic,
			"Include monotonic seconds in timestamp", NULL},
		{ NULL }
	};
	GError *error = NULL;
	GOptionContext *context;

	context = g_option_context_new ("- implements syslogd");
	g_option_context_add_main_entries (context, entries, NULL);
	if (!g_option_context_parse (context, &argc, &argv, &error))
	{
		if (error) {
			ErrPrint("%s: option parsing failed: %s\n", __FUNCTION__, error->message);
			g_error_free(error);
		}
        ret = RESULT_PARAM_ERR;
	}
    g_option_context_free(context);
    return ret;
}

gint char_array_comp_func(gconstpointer a, gconstpointer b, gpointer user_data) {
	const gchar *ga = a;
	const gchar *gb = b;
	return strcmp(ga,gb);
}

/**
 * @brief InitConfig
 * Initial setup of configuration
 */
static void InitConfig(void)
{
	g_numOutputs = 0;
	g_numContexts = 0;

	memset(&g_outputConfs, 0, sizeof(g_outputConfs));
	g_contextConfs = g_tree_new_full( char_array_comp_func, NULL, g_free, free );

	/* TODO : Validation for result of PmLogReadConfigs() */
	PmLogPrvReadConfigs(ParseJsonOutputs);
	PmLogPrvReadConfigs(ParseJsonContexts);
}

/**
 * @brief main
 *
 * @param argc
 * @param argv
 *
 * @return
 */
int main(int argc, char* argv[])
{
	int           result;

	InitSettings();

	result = ParseParams(argc, argv);
	if (result != RESULT_OK)
		exit(EXIT_FAILURE);

	DbgPrint("PmLogDaemon running...\n");

	InitConfig();

	/* make sure we aren't already running */
	if (!LockProcess("PmLogDaemon"))
	{
		exit(EXIT_FAILURE);
	}

	/* service the syslog socket */
	result = RunSysLogD();
	if (result != RESULT_OK)
	{
		exit(EXIT_FAILURE);
	}

	exit(EXIT_SUCCESS);
}
